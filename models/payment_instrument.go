// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PaymentInstrument payment instrument
//
// swagger:model PaymentInstrument
type PaymentInstrument struct {

	// links
	Links *PaymentInstrumentLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PaymentInstrumentBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PaymentInstrumentBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PaymentInstrumentBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PaymentInstrumentCard `json:"card,omitempty"`

	// Unique identification number assigned by CyberSource to the submitted request.
	// Example: 1234567890123456800
	// Read Only: true
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PaymentInstrumentInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PaymentInstrumentMerchantInformation `json:"merchantInformation,omitempty"`

	// meta data
	MetaData *PaymentInstrumentMetaData `json:"metaData,omitempty"`

	// 'Describes type of token.'
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PaymentInstrumentProcessingInformation `json:"processingInformation,omitempty"`

	// 'Current state of the token.'
	//
	// Valid values:
	// - ACTIVE
	// - CLOSED
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this payment instrument
func (m *PaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetaData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrument) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.BankAccount) { // not required
		return nil
	}

	if m.BankAccount != nil {
		if err := m.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(m.BillTo) { // not required
		return nil
	}

	if m.BillTo != nil {
		if err := m.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.BuyerInformation) { // not required
		return nil
	}

	if m.BuyerInformation != nil {
		if err := m.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.InstrumentIdentifier) { // not required
		return nil
	}

	if m.InstrumentIdentifier != nil {
		if err := m.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantInformation) { // not required
		return nil
	}

	if m.MerchantInformation != nil {
		if err := m.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateMetaData(formats strfmt.Registry) error {
	if swag.IsZero(m.MetaData) { // not required
		return nil
	}

	if m.MetaData != nil {
		if err := m.MetaData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metaData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metaData")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessingInformation) { // not required
		return nil
	}

	if m.ProcessingInformation != nil {
		if err := m.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument based on the context it is used
func (m *PaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetaData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrument) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.BankAccount != nil {

		if swag.IsZero(m.BankAccount) { // not required
			return nil
		}

		if err := m.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if m.BillTo != nil {

		if swag.IsZero(m.BillTo) { // not required
			return nil
		}

		if err := m.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.BuyerInformation != nil {

		if swag.IsZero(m.BuyerInformation) { // not required
			return nil
		}

		if err := m.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if m.Card != nil {

		if swag.IsZero(m.Card) { // not required
			return nil
		}

		if err := m.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrument) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if m.InstrumentIdentifier != nil {

		if swag.IsZero(m.InstrumentIdentifier) { // not required
			return nil
		}

		if err := m.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantInformation != nil {

		if swag.IsZero(m.MerchantInformation) { // not required
			return nil
		}

		if err := m.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateMetaData(ctx context.Context, formats strfmt.Registry) error {

	if m.MetaData != nil {

		if swag.IsZero(m.MetaData) { // not required
			return nil
		}

		if err := m.MetaData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metaData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metaData")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "object", "body", string(m.Object)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrument) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.ProcessingInformation != nil {

		if swag.IsZero(m.ProcessingInformation) { // not required
			return nil
		}

		if err := m.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrument) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrument) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrument) UnmarshalBinary(b []byte) error {
	var res PaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBankAccount payment instrument bank account
//
// swagger:model PaymentInstrumentBankAccount
type PaymentInstrumentBankAccount struct {

	// Checking account type. Possible values:
	//   * C: checking
	//   * S: savings (USD only)
	//   * X: corporate checking (USD only)
	//   * G: general ledger
	//
	// Example: savings
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instrument bank account
func (m *PaymentInstrumentBankAccount) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument bank account based on context it is used
func (m *PaymentInstrumentBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBankAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBankAccount) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBillTo payment instrument bill to
//
// swagger:model PaymentInstrumentBillTo
type PaymentInstrumentBillTo struct {

	// First line of the billing street address.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: 12 Main Street
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	// Example: 20 My Street
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. For an address in the U.S. or Canada, use the State, Province, and Territory Codes for the United States and Canada.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: CA
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer’s company.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: CyberSource
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Country of the billing address. Accepts input in the ISO 3166-1 standard, stores as ISO 3166-1-Alpha-2.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: US
	// Max Length: 3
	// Min Length: 2
	Country string `json:"country,omitempty"`

	// Customer’s email address.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: john.smith@example.com
	// Max Length: 320
	Email string `json:"email,omitempty"`

	// Customer’s first name. For a credit card transaction, this name must match the name on the card.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: John
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. For a credit card transaction, this name must match the name on the card.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: Smith
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the billing address.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: Foster City
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer phone number. When you create a customer profile, the requirements depend on the payment method:
	//   * Credit cards — optional.
	//   * Electronic checks — contact your payment processor representative to find out if this field is required or optional.
	//   * PINless debits — optional.
	//
	// Example: 555123456
	// Max Length: 32
	// Min Length: 6
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	// **Example** 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space]
	// [numeric][alpha][numeric]
	// Example A1B 2C3
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: 90200
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this payment instrument bill to
func (m *PaymentInstrumentBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(m.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address1", "body", m.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(m.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address2", "body", m.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(m.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"administrativeArea", "body", m.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(m.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"company", "body", m.Company, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MinLength("billTo"+"."+"country", "body", m.Country, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("billTo"+"."+"country", "body", m.Country, 3); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"email", "body", m.Email, 320); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(m.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"firstName", "body", m.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(m.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"lastName", "body", m.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(m.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"locality", "body", m.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MinLength("billTo"+"."+"phoneNumber", "body", m.PhoneNumber, 6); err != nil {
		return err
	}

	if err := validate.MaxLength("billTo"+"."+"phoneNumber", "body", m.PhoneNumber, 32); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"postalCode", "body", m.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instrument bill to based on context it is used
func (m *PaymentInstrumentBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBillTo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBillTo) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBuyerInformation payment instrument buyer information
//
// swagger:model PaymentInstrumentBuyerInformation
type PaymentInstrumentBuyerInformation struct {

	// Tax identifier for the customer’s company.
	//
	// **Important**:
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// Example: 1234567890123456800
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used by the customer. Accepts input in the ISO 4217 standard, stores as ISO 4217 Alpha.
	// Example: USD
	// Max Length: 3
	// Min Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer.
	//
	// Format: `YYYY-MM-DD` or `YYYYMMDD`
	//
	// Example: 1960-12-30
	// Max Length: 10
	// Min Length: 8
	DateOBirth string `json:"dateOBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PaymentInstrumentBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this payment instrument buyer information
func (m *PaymentInstrumentBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateOBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(m.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerInformation"+"."+"companyTaxID", "body", m.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if err := validate.MinLength("buyerInformation"+"."+"currency", "body", m.Currency, 3); err != nil {
		return err
	}

	if err := validate.MaxLength("buyerInformation"+"."+"currency", "body", m.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformation) validateDateOBirth(formats strfmt.Registry) error {
	if swag.IsZero(m.DateOBirth) { // not required
		return nil
	}

	if err := validate.MinLength("buyerInformation"+"."+"dateOBirth", "body", m.DateOBirth, 8); err != nil {
		return err
	}

	if err := validate.MaxLength("buyerInformation"+"."+"dateOBirth", "body", m.DateOBirth, 10); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(m.PersonalIdentification); i++ {
		if swag.IsZero(m.PersonalIdentification[i]) { // not required
			continue
		}

		if m.PersonalIdentification[i] != nil {
			if err := m.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this payment instrument buyer information based on the context it is used
func (m *PaymentInstrumentBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PersonalIdentification); i++ {

		if m.PersonalIdentification[i] != nil {

			if swag.IsZero(m.PersonalIdentification[i]) { // not required
				return nil
			}

			if err := m.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBuyerInformationPersonalIdentificationItems0 payment instrument buyer information personal identification items0
//
// swagger:model PaymentInstrumentBuyerInformationPersonalIdentificationItems0
type PaymentInstrumentBuyerInformationPersonalIdentificationItems0 struct {

	// Customer's identification number.
	//
	// **Important**:
	// Contact your TeleCheck representative to learn whether this field is required or optional.
	//
	// Example: 1234567890
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// Type of personal identification.
	// **Important**:
	// Contact your TeleCheck representative to learn whether this field is required or optional.
	//
	// Valid values:
	// - driver license
	//
	// Example: driver license
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instrument buyer information personal identification items0
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.IssuedBy) { // not required
		return nil
	}

	if m.IssuedBy != nil {
		if err := m.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument buyer information personal identification items0 based on the context it is used
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if m.IssuedBy != nil {

		if swag.IsZero(m.IssuedBy) { // not required
			return nil
		}

		if err := m.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy payment instrument buyer information personal identification items0 issued by
//
// swagger:model PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
type PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// State or province in which the customer’s driver’s license was issued. Use the State, Province, and Territory Codes for the United States and Canada.
	//
	// **Important**:
	// Contact your TeleCheck representative to learn whether this field is required or optional.
	//
	// Example: CA
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this payment instrument buyer information personal identification items0 issued by
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument buyer information personal identification items0 issued by based on context it is used
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentCard payment instrument card
//
// swagger:model PaymentInstrumentCard
type PaymentInstrumentCard struct {

	// Two-digit month in which the credit card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. For more information about relaxed requirements, see the TMS REST API Developer Guide.
	//
	// Important:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: 12
	// Max Length: 2
	// Min Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	// Format: `YYYY`.
	// Possible values: `1900` through `2099`.
	//
	// **FDC Nashville Global and FDMS South**
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. For details, see [Relaxed Requirements for Address Data and Expiration Date.](https://www.cybersource.com/developers/integration_methods/relax_avs/).
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.'
	//
	// Example: 2022
	// Max Length: 4
	// Min Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder.
	// Example: 01
	// Max Length: 2
	// Min Length: 1
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period.
	//
	// Format: `MM`.
	// Possible values: `01` through `12`.
	//
	// Example: 12
	// Max Length: 2
	// Min Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period.
	//
	// Format: `YYYY`.
	// Possible values: `1900` through `2099`.
	//
	// Example: 2022
	// Max Length: 4
	// Min Length: 4
	StartYear string `json:"startYear,omitempty"`

	// Type of credit card. Possible values:
	//   * **visa** -- Visa (001)
	//   * **mastercard** -- Mastercard (002) - Eurocard—European regional brand of Mastercard
	//   * **american express** -- American Express (003)
	//   * **discover** -- Discover (004)
	//   * **diners club** -- Diners Club (005)
	//   * **carte blanche** -- Carte Blanche (006)
	//   * **jcb** -- JCB (007)
	//   * **optima** -- Optima (008)
	//   * **twinpay credit** -- Twinpay Credit (011)
	//   * **twinpay debit** -- Twinpay Debit (012)
	//   * **walmart** -- Walmart (013)
	//   * **enroute** -- EnRoute (014)
	//   * **lowes consumer** -- Lowes consumer (015)
	//   * **home depot consumer** -- Home Depot consumer (016)
	//   * **mbna** -- MBNA (017)
	//   * **dicks sportswear** -- Dicks Sportswear (018)
	//   * **casual corner** -- Casual Corner (019)
	//   * **sears** -- Sears (020)
	//   * **jal** -- JAL (021)
	//   * **disney** -- Disney (023)
	//   * **maestro uk domestic** -- Maestro (024) - UK Domestic
	//   * **sams club consumer** -- Sams Club consumer (025)
	//   * **sams club business** -- Sams Club business (026)
	//   * **bill me later** -- Bill me later (028)
	//   * **bebe** -- Bebe (029)
	//   * **restoration hardware** -- Restoration Hardware (030)
	//   * **delta online** -- Delta (031) — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * **solo** -- Solo (032)
	//   * **visa electron** -- Visa Electron (033)
	//   * **dankort** -- Dankort (034)
	//   * **laser** -- Laser (035)
	//   * **carte bleue** -- Carte Bleue (036) — formerly Cartes Bancaires
	//   * **carta si** -- Carta Si (037)
	//   * **pinless debit** -- pinless debit (038)
	//   * **encoded account** -- encoded account (039)
	//   * **uatp** -- UATP (040)
	//   * **household** -- Household (041)
	//   * **maestro international** -- Maestro (042) - International
	//   * **ge money uk** -- GE Money UK (043)
	//   * **korean cards** -- Korean cards (044)
	//   * **style** -- Style (045)
	//   * **jcrew** -- JCrew (046)
	//   * **payease china processing ewallet** -- PayEase China processing eWallet (047)
	//   * **payease china processing bank transfer** -- PayEase China processing bank transfer (048)
	//   * **meijer private label** -- Meijer Private Label (049)
	//   * **hipercard** -- Hipercard (050) — supported only by the Comercio Latino processor.
	//   * **aura** -- Aura (051) — supported only by the Comercio Latino processor.
	//   * **redecard** -- Redecard (052)
	//   * **elo** -- Elo (054) — supported only by the Comercio Latino processor.
	//   * **capital one private label** -- Capital One Private Label (055)
	//   * **synchrony private label** -- Synchrony Private Label (056)
	//   * **costco private label** -- Costco Private Label (057)
	//   * **mada** -- mada (060)
	//   * **china union pay** -- China Union Pay (062)
	//   * **falabella private label** -- Falabella private label (063)
	//
	// Required: true
	Type *string `json:"type"`

	// Card Use As Field. Supported value of `pinless debit` only. Only for use with Pinless Debit tokens.
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this payment instrument card
func (m *PaymentInstrumentCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"expirationMonth", "body", m.ExpirationMonth, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"expirationMonth", "body", m.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"expirationYear", "body", m.ExpirationYear, 4); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"expirationYear", "body", m.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.IssueNumber) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"issueNumber", "body", m.IssueNumber, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"issueNumber", "body", m.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(m.StartMonth) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"startMonth", "body", m.StartMonth, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"startMonth", "body", m.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(m.StartYear) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"startYear", "body", m.StartYear, 4); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"startYear", "body", m.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentCard) validateType(formats strfmt.Registry) error {

	if err := validate.Required("card"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instrument card based on context it is used
func (m *PaymentInstrumentCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifier payment instrument instrument identifier
//
// swagger:model PaymentInstrumentInstrumentIdentifier
type PaymentInstrumentInstrumentIdentifier struct {

	// links
	Links *PaymentInstrumentInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PaymentInstrumentInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// card
	Card *PaymentInstrumentInstrumentIdentifierCard `json:"card,omitempty"`

	// The ID of the existing instrument identifier to be linked to the newly created payment instrument.
	// Example: 1234567890123456789
	// Max Length: 32
	// Min Length: 16
	ID string `json:"id,omitempty"`

	// metadata
	Metadata *PaymentInstrumentInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// 'Describes type of token.'
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PaymentInstrumentInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// 'Current state of the token.'
	//
	// Valid values:
	// - ACTIVE
	// - CLOSED
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this payment instrument instrument identifier
func (m *PaymentInstrumentInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.BankAccount) { // not required
		return nil
	}

	if m.BankAccount != nil {
		if err := m.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"id", "body", m.ID, 16); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"id", "body", m.ID, 32); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessingInformation) { // not required
		return nil
	}

	if m.ProcessingInformation != nil {
		if err := m.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument instrument identifier based on the context it is used
func (m *PaymentInstrumentInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.BankAccount != nil {

		if swag.IsZero(m.BankAccount) { // not required
			return nil
		}

		if err := m.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if m.Card != nil {

		if swag.IsZero(m.Card) { // not required
			return nil
		}

		if err := m.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {

		if swag.IsZero(m.Metadata) { // not required
			return nil
		}

		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instrumentIdentifier"+"."+"object", "body", string(m.Object)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.ProcessingInformation != nil {

		if swag.IsZero(m.ProcessingInformation) { // not required
			return nil
		}

		if err := m.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instrumentIdentifier"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierBankAccount payment instrument instrument identifier bank account
//
// swagger:model PaymentInstrumentInstrumentIdentifierBankAccount
type PaymentInstrumentInstrumentIdentifierBankAccount struct {

	// Checking account number.
	// Example: 1234567890123456800
	// Max Length: 19
	// Min Length: 1
	Number string `json:"number,omitempty"`

	// Routing number.
	// Example: 123456789
	// Max Length: 9
	// Min Length: 1
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this payment instrument instrument identifier bank account
func (m *PaymentInstrumentInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", m.Number, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", m.Number, 19); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierBankAccount) validateRoutingNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.RoutingNumber) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"bankAccount"+"."+"routingNumber", "body", m.RoutingNumber, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"bankAccount"+"."+"routingNumber", "body", m.RoutingNumber, 9); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instrument instrument identifier bank account based on context it is used
func (m *PaymentInstrumentInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierCard payment instrument instrument identifier card
//
// swagger:model PaymentInstrumentInstrumentIdentifierCard
type PaymentInstrumentInstrumentIdentifierCard struct {

	// Customer’s credit card number.
	// Example: 1234567890987654
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`
}

// Validate validates this payment instrument instrument identifier card
func (m *PaymentInstrumentInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"card"+"."+"number", "body", m.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"card"+"."+"number", "body", m.Number, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instrument instrument identifier card based on context it is used
func (m *PaymentInstrumentInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierLinks payment instrument instrument identifier links
//
// swagger:model PaymentInstrumentInstrumentIdentifierLinks
type PaymentInstrumentInstrumentIdentifierLinks struct {

	// ancestor
	Ancestor *PaymentInstrumentInstrumentIdentifierLinksAncestor `json:"ancestor,omitempty"`

	// self
	Self *PaymentInstrumentInstrumentIdentifierLinksSelf `json:"self,omitempty"`

	// successor
	Successor *PaymentInstrumentInstrumentIdentifierLinksSuccessor `json:"successor,omitempty"`
}

// Validate validates this payment instrument instrument identifier links
func (m *PaymentInstrumentInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAncestor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuccessor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierLinks) validateAncestor(formats strfmt.Registry) error {
	if swag.IsZero(m.Ancestor) { // not required
		return nil
	}

	if m.Ancestor != nil {
		if err := m.Ancestor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierLinks) validateSuccessor(formats strfmt.Registry) error {
	if swag.IsZero(m.Successor) { // not required
		return nil
	}

	if m.Successor != nil {
		if err := m.Successor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument instrument identifier links based on the context it is used
func (m *PaymentInstrumentInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAncestor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuccessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierLinks) contextValidateAncestor(ctx context.Context, formats strfmt.Registry) error {

	if m.Ancestor != nil {

		if swag.IsZero(m.Ancestor) { // not required
			return nil
		}

		if err := m.Ancestor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {

		if swag.IsZero(m.Self) { // not required
			return nil
		}

		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierLinks) contextValidateSuccessor(ctx context.Context, formats strfmt.Registry) error {

	if m.Successor != nil {

		if swag.IsZero(m.Successor) { // not required
			return nil
		}

		if err := m.Successor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierLinksAncestor payment instrument instrument identifier links ancestor
//
// swagger:model PaymentInstrumentInstrumentIdentifierLinksAncestor
type PaymentInstrumentInstrumentIdentifierLinksAncestor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument instrument identifier links ancestor
func (m *PaymentInstrumentInstrumentIdentifierLinksAncestor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument instrument identifier links ancestor based on context it is used
func (m *PaymentInstrumentInstrumentIdentifierLinksAncestor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinksAncestor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinksAncestor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierLinksAncestor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierLinksSelf payment instrument instrument identifier links self
//
// swagger:model PaymentInstrumentInstrumentIdentifierLinksSelf
type PaymentInstrumentInstrumentIdentifierLinksSelf struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument instrument identifier links self
func (m *PaymentInstrumentInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument instrument identifier links self based on context it is used
func (m *PaymentInstrumentInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierLinksSuccessor payment instrument instrument identifier links successor
//
// swagger:model PaymentInstrumentInstrumentIdentifierLinksSuccessor
type PaymentInstrumentInstrumentIdentifierLinksSuccessor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument instrument identifier links successor
func (m *PaymentInstrumentInstrumentIdentifierLinksSuccessor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument instrument identifier links successor based on context it is used
func (m *PaymentInstrumentInstrumentIdentifierLinksSuccessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinksSuccessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierLinksSuccessor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierLinksSuccessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierMetadata payment instrument instrument identifier metadata
//
// swagger:model PaymentInstrumentInstrumentIdentifierMetadata
type PaymentInstrumentInstrumentIdentifierMetadata struct {

	// The creator of the token.
	// Example: merchantName
	Creator string `json:"creator,omitempty"`
}

// Validate validates this payment instrument instrument identifier metadata
func (m *PaymentInstrumentInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this payment instrument instrument identifier metadata based on the context it is used
func (m *PaymentInstrumentInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierProcessingInformation payment instrument instrument identifier processing information
//
// swagger:model PaymentInstrumentInstrumentIdentifierProcessingInformation
type PaymentInstrumentInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this payment instrument instrument identifier processing information
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizationOptions) { // not required
		return nil
	}

	if m.AuthorizationOptions != nil {
		if err := m.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument instrument identifier processing information based on the context it is used
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthorizationOptions != nil {

		if swag.IsZero(m.AuthorizationOptions) { // not required
			return nil
		}

		if err := m.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions payment instrument instrument identifier processing information authorization options
//
// swagger:model PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions
type PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this payment instrument instrument identifier processing information authorization options
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(m.Initiator) { // not required
		return nil
	}

	if m.Initiator != nil {
		if err := m.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument instrument identifier processing information authorization options based on the context it is used
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if m.Initiator != nil {

		if swag.IsZero(m.Initiator) { // not required
			return nil
		}

		if err := m.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator payment instrument instrument identifier processing information authorization options initiator
//
// swagger:model PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
type PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this payment instrument instrument identifier processing information authorization options initiator
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if m.MerchantInitiatedTransaction != nil {
		if err := m.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument instrument identifier processing information authorization options initiator based on the context it is used
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantInitiatedTransaction != nil {

		if swag.IsZero(m.MerchantInitiatedTransaction) { // not required
			return nil
		}

		if err := m.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction payment instrument instrument identifier processing information authorization options initiator merchant initiated transaction
//
// swagger:model PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
type PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Previous Consumer Initiated Transaction Id.
	// Example: 123456789012345
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this payment instrument instrument identifier processing information authorization options initiator merchant initiated transaction
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(m.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", m.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instrument instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinks payment instrument links
//
// swagger:model PaymentInstrumentLinks
type PaymentInstrumentLinks struct {

	// ancestor
	Ancestor *PaymentInstrumentLinksAncestor `json:"ancestor,omitempty"`

	// self
	Self *PaymentInstrumentLinksSelf `json:"self,omitempty"`

	// successor
	Successor *PaymentInstrumentLinksSuccessor `json:"successor,omitempty"`
}

// Validate validates this payment instrument links
func (m *PaymentInstrumentLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAncestor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuccessor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentLinks) validateAncestor(formats strfmt.Registry) error {
	if swag.IsZero(m.Ancestor) { // not required
		return nil
	}

	if m.Ancestor != nil {
		if err := m.Ancestor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentLinks) validateSuccessor(formats strfmt.Registry) error {
	if swag.IsZero(m.Successor) { // not required
		return nil
	}

	if m.Successor != nil {
		if err := m.Successor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument links based on the context it is used
func (m *PaymentInstrumentLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAncestor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuccessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentLinks) contextValidateAncestor(ctx context.Context, formats strfmt.Registry) error {

	if m.Ancestor != nil {

		if swag.IsZero(m.Ancestor) { // not required
			return nil
		}

		if err := m.Ancestor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {

		if swag.IsZero(m.Self) { // not required
			return nil
		}

		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentLinks) contextValidateSuccessor(ctx context.Context, formats strfmt.Registry) error {

	if m.Successor != nil {

		if swag.IsZero(m.Successor) { // not required
			return nil
		}

		if err := m.Successor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinks) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinksAncestor payment instrument links ancestor
//
// swagger:model PaymentInstrumentLinksAncestor
type PaymentInstrumentLinksAncestor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument links ancestor
func (m *PaymentInstrumentLinksAncestor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument links ancestor based on context it is used
func (m *PaymentInstrumentLinksAncestor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinksAncestor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinksAncestor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinksAncestor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinksSelf payment instrument links self
//
// swagger:model PaymentInstrumentLinksSelf
type PaymentInstrumentLinksSelf struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument links self
func (m *PaymentInstrumentLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument links self based on context it is used
func (m *PaymentInstrumentLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentLinksSuccessor payment instrument links successor
//
// swagger:model PaymentInstrumentLinksSuccessor
type PaymentInstrumentLinksSuccessor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instrument links successor
func (m *PaymentInstrumentLinksSuccessor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument links successor based on context it is used
func (m *PaymentInstrumentLinksSuccessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentLinksSuccessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentLinksSuccessor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentLinksSuccessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentMerchantInformation payment instrument merchant information
//
// swagger:model PaymentInstrumentMerchantInformation
type PaymentInstrumentMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PaymentInstrumentMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this payment instrument merchant information
func (m *PaymentInstrumentMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantDescriptor) { // not required
		return nil
	}

	if m.MerchantDescriptor != nil {
		if err := m.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument merchant information based on the context it is used
func (m *PaymentInstrumentMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantDescriptor != nil {

		if swag.IsZero(m.MerchantDescriptor) { // not required
			return nil
		}

		if err := m.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentMerchantInformationMerchantDescriptor payment instrument merchant information merchant descriptor
//
// swagger:model PaymentInstrumentMerchantInformationMerchantDescriptor
type PaymentInstrumentMerchantInformationMerchantDescriptor struct {

	// Alternate information for your business. This API field overrides the company entry description value in your CyberSource account.
	// Example: Branch Name
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this payment instrument merchant information merchant descriptor
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument merchant information merchant descriptor based on context it is used
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentMetaData payment instrument meta data
//
// swagger:model PaymentInstrumentMetaData
type PaymentInstrumentMetaData struct {

	// The creator of the token.
	// Example: merchantName
	Creator string `json:"creator,omitempty"`
}

// Validate validates this payment instrument meta data
func (m *PaymentInstrumentMetaData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this payment instrument meta data based on the context it is used
func (m *PaymentInstrumentMetaData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentMetaData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentMetaData) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentMetaData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentProcessingInformation payment instrument processing information
//
// swagger:model PaymentInstrumentProcessingInformation
type PaymentInstrumentProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PaymentInstrumentProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Indicates that the payments for this customer profile are for the Bill Payment program. Possible values:
	//   * false: Not a Visa Bill Payment.
	//   * true: Visa Bill Payment.
	//
	// Example: true
	BillPaymentProgramEnabled *bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this payment instrument processing information
func (m *PaymentInstrumentProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.BankTransferOptions) { // not required
		return nil
	}

	if m.BankTransferOptions != nil {
		if err := m.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instrument processing information based on the context it is used
func (m *PaymentInstrumentProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.BankTransferOptions != nil {

		if swag.IsZero(m.BankTransferOptions) { // not required
			return nil
		}

		if err := m.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentProcessingInformationBankTransferOptions payment instrument processing information bank transfer options
//
// swagger:model PaymentInstrumentProcessingInformationBankTransferOptions
type PaymentInstrumentProcessingInformationBankTransferOptions struct {

	// **Important** This field is required if your processor is TeleCheck.
	//
	// Code that specifies the authorization method for the transaction. Possible values:
	//
	// - **CCD**: corporate cash disbursement. Charge or credit against a business checking account. You can use one-time or recurring CCD transactions to transfer funds to or from a corporate entity. A standing authorization is required for recurring transactions.
	// - **PPD**: prearranged payment and deposit entry. Charge or credit against a personal checking or savings account. You can originate a PPD entry only when the payment and deposit terms between you and the customer are prearranged. A written authorization from the customer is required for one-time transactions and a written standing authorization is required for recurring transactions.
	// - **TEL**: telephone-initiated entry. One-time charge against a personal checking or savings account. You can originate a TEL entry only when there is a business relationship between you and the customer or when the customer initiates a telephone call to you. For a TEL entry, you must obtain a payment authorization from the customer over the telephone. There is no recurring billing option for TEL.
	// - **WEB**: internet-initiated entry—charge against a personal checking or savings account. You can originate a one-time or recurring WEB entry when the customer initiates the transaction over the Internet. For a WEB entry, you must obtain payment authorization from the customer over the Internet.
	//
	// Example: WEB
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this payment instrument processing information bank transfer options
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instrument processing information bank transfer options based on context it is used
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
