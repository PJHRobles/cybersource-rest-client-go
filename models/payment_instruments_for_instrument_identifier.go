// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PaymentInstrumentsForInstrumentIdentifier payment instruments for instrument identifier
//
// swagger:model PaymentInstrumentsForInstrumentIdentifier
type PaymentInstrumentsForInstrumentIdentifier struct {

	// embedded
	Embedded *PaymentInstrumentsForInstrumentIdentifierEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PaymentInstrumentsForInstrumentIdentifierLinks `json:"_links,omitempty"`

	// The number of Payment Instruments returned in the array.
	// Example: 1
	// Read Only: true
	Count string `json:"count,omitempty"`

	// The limit parameter supplied in the request.
	// Example: 1
	// Read Only: true
	Limit string `json:"limit,omitempty"`

	// 'Shows the response is a collection of objects.'
	//
	// Valid values:
	// - collection
	//
	// Example: collection
	// Read Only: true
	Object string `json:"object,omitempty"`

	// The offset parameter supplied in the request.
	// Example: 20
	// Read Only: true
	Offset string `json:"offset,omitempty"`

	// The total number of Payment Instruments associated with the Instrument Identifier in the zero-based dataset.
	// Example: 39
	// Read Only: true
	Total string `json:"total,omitempty"`
}

// Validate validates this payment instruments for instrument identifier
func (m *PaymentInstrumentsForInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(m.Embedded) { // not required
		return nil
	}

	if m.Embedded != nil {
		if err := m.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOffset(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if m.Embedded != nil {

		if swag.IsZero(m.Embedded) { // not required
			return nil
		}

		if err := m.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "count", "body", string(m.Count)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateLimit(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "limit", "body", string(m.Limit)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "object", "body", string(m.Object)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateOffset(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "offset", "body", string(m.Offset)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifier) contextValidateTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "total", "body", string(m.Total)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbedded payment instruments for instrument identifier embedded
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbedded
type PaymentInstrumentsForInstrumentIdentifierEmbedded struct {

	// Array of Payment Instruments returned for the supplied Instrument Identifier.
	PaymentInstruments []*PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0 `json:"paymentInstruments"`
}

// Validate validates this payment instruments for instrument identifier embedded
func (m *PaymentInstrumentsForInstrumentIdentifierEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbedded) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentInstruments) { // not required
		return nil
	}

	for i := 0; i < len(m.PaymentInstruments); i++ {
		if swag.IsZero(m.PaymentInstruments[i]) { // not required
			continue
		}

		if m.PaymentInstruments[i] != nil {
			if err := m.PaymentInstruments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbedded) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PaymentInstruments); i++ {

		if m.PaymentInstruments[i] != nil {

			if swag.IsZero(m.PaymentInstruments[i]) { // not required
				return nil
			}

			if err := m.PaymentInstruments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbedded) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbedded) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0 payment instruments for instrument identifier embedded payment instruments items0
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0 struct {

	// links
	Links *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links `json:"_links,omitempty"`

	// bank account
	BankAccount *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card `json:"card,omitempty"`

	// Unique identification number assigned by CyberSource to the submitted request.
	// Example: 1234567890123456800
	// Read Only: true
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation `json:"merchantInformation,omitempty"`

	// meta data
	MetaData *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData `json:"metaData,omitempty"`

	// 'Describes type of token.'
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation `json:"processingInformation,omitempty"`

	// 'Current state of the token.'
	//
	// Valid values:
	// - ACTIVE
	// - CLOSED
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetaData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.BankAccount) { // not required
		return nil
	}

	if m.BankAccount != nil {
		if err := m.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(m.BillTo) { // not required
		return nil
	}

	if m.BillTo != nil {
		if err := m.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.BuyerInformation) { // not required
		return nil
	}

	if m.BuyerInformation != nil {
		if err := m.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.InstrumentIdentifier) { // not required
		return nil
	}

	if m.InstrumentIdentifier != nil {
		if err := m.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantInformation) { // not required
		return nil
	}

	if m.MerchantInformation != nil {
		if err := m.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateMetaData(formats strfmt.Registry) error {
	if swag.IsZero(m.MetaData) { // not required
		return nil
	}

	if m.MetaData != nil {
		if err := m.MetaData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metaData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metaData")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessingInformation) { // not required
		return nil
	}

	if m.ProcessingInformation != nil {
		if err := m.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetaData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.BankAccount != nil {

		if swag.IsZero(m.BankAccount) { // not required
			return nil
		}

		if err := m.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if m.BillTo != nil {

		if swag.IsZero(m.BillTo) { // not required
			return nil
		}

		if err := m.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.BuyerInformation != nil {

		if swag.IsZero(m.BuyerInformation) { // not required
			return nil
		}

		if err := m.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if m.Card != nil {

		if swag.IsZero(m.Card) { // not required
			return nil
		}

		if err := m.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if m.InstrumentIdentifier != nil {

		if swag.IsZero(m.InstrumentIdentifier) { // not required
			return nil
		}

		if err := m.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantInformation != nil {

		if swag.IsZero(m.MerchantInformation) { // not required
			return nil
		}

		if err := m.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateMetaData(ctx context.Context, formats strfmt.Registry) error {

	if m.MetaData != nil {

		if swag.IsZero(m.MetaData) { // not required
			return nil
		}

		if err := m.MetaData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metaData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metaData")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "object", "body", string(m.Object)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.ProcessingInformation != nil {

		if swag.IsZero(m.ProcessingInformation) { // not required
			return nil
		}

		if err := m.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount payment instruments for instrument identifier embedded payment instruments items0 bank account
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount struct {

	// Checking account type. Possible values:
	//   * C: checking
	//   * S: savings (USD only)
	//   * X: corporate checking (USD only)
	//   * G: general ledger
	//
	// Example: savings
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 bank account
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 bank account based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo payment instruments for instrument identifier embedded payment instruments items0 bill to
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo struct {

	// First line of the billing street address.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: 12 Main Street
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	// Example: 20 My Street
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. For an address in the U.S. or Canada, use the State, Province, and Territory Codes for the United States and Canada.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: CA
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer’s company.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: CyberSource
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Country of the billing address. Accepts input in the ISO 3166-1 standard, stores as ISO 3166-1-Alpha-2.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: US
	// Max Length: 3
	// Min Length: 2
	Country string `json:"country,omitempty"`

	// Customer’s email address.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: john.smith@example.com
	// Max Length: 320
	Email string `json:"email,omitempty"`

	// Customer’s first name. For a credit card transaction, this name must match the name on the card.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: John
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. For a credit card transaction, this name must match the name on the card.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: Smith
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the billing address.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: Foster City
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer phone number. When you create a customer profile, the requirements depend on the payment method:
	//   * Credit cards — optional.
	//   * Electronic checks — contact your payment processor representative to find out if this field is required or optional.
	//   * PINless debits — optional.
	//
	// Example: 555123456
	// Max Length: 32
	// Min Length: 6
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	// **Example** 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space]
	// [numeric][alpha][numeric]
	// Example A1B 2C3
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. See the TMS REST Developer Guide for more information about relaxed address requirements.
	//
	// **Important**:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: 90200
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 bill to
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(m.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address1", "body", m.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(m.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address2", "body", m.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(m.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"administrativeArea", "body", m.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(m.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"company", "body", m.Company, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(m.Country) { // not required
		return nil
	}

	if err := validate.MinLength("billTo"+"."+"country", "body", m.Country, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("billTo"+"."+"country", "body", m.Country, 3); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"email", "body", m.Email, 320); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(m.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"firstName", "body", m.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(m.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"lastName", "body", m.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(m.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"locality", "body", m.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MinLength("billTo"+"."+"phoneNumber", "body", m.PhoneNumber, 6); err != nil {
		return err
	}

	if err := validate.MaxLength("billTo"+"."+"phoneNumber", "body", m.PhoneNumber, 32); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(m.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"postalCode", "body", m.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 bill to based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation payment instruments for instrument identifier embedded payment instruments items0 buyer information
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation struct {

	// Tax identifier for the customer’s company.
	//
	// **Important**:
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// Example: 1234567890123456800
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used by the customer. Accepts input in the ISO 4217 standard, stores as ISO 4217 Alpha.
	// Example: USD
	// Max Length: 3
	// Min Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer.
	//
	// Format: `YYYY-MM-DD` or `YYYYMMDD`
	//
	// Example: 1960-12-30
	// Max Length: 10
	// Min Length: 8
	DateOBirth string `json:"dateOBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 buyer information
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateOBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(m.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerInformation"+"."+"companyTaxID", "body", m.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if err := validate.MinLength("buyerInformation"+"."+"currency", "body", m.Currency, 3); err != nil {
		return err
	}

	if err := validate.MaxLength("buyerInformation"+"."+"currency", "body", m.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) validateDateOBirth(formats strfmt.Registry) error {
	if swag.IsZero(m.DateOBirth) { // not required
		return nil
	}

	if err := validate.MinLength("buyerInformation"+"."+"dateOBirth", "body", m.DateOBirth, 8); err != nil {
		return err
	}

	if err := validate.MaxLength("buyerInformation"+"."+"dateOBirth", "body", m.DateOBirth, 10); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(m.PersonalIdentification); i++ {
		if swag.IsZero(m.PersonalIdentification[i]) { // not required
			continue
		}

		if m.PersonalIdentification[i] != nil {
			if err := m.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 buyer information based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PersonalIdentification); i++ {

		if m.PersonalIdentification[i] != nil {

			if swag.IsZero(m.PersonalIdentification[i]) { // not required
				return nil
			}

			if err := m.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0 payment instruments for instrument identifier embedded payment instruments items0 buyer information personal identification items0
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0 struct {

	// Customer's identification number.
	//
	// **Important**:
	// Contact your TeleCheck representative to learn whether this field is required or optional.
	//
	// Example: 1234567890
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// Type of personal identification.
	// **Important**:
	// Contact your TeleCheck representative to learn whether this field is required or optional.
	//
	// Valid values:
	// - driver license
	//
	// Example: driver license
	Type string `json:"type,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 buyer information personal identification items0
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.IssuedBy) { // not required
		return nil
	}

	if m.IssuedBy != nil {
		if err := m.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 buyer information personal identification items0 based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if m.IssuedBy != nil {

		if swag.IsZero(m.IssuedBy) { // not required
			return nil
		}

		if err := m.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy payment instruments for instrument identifier embedded payment instruments items0 buyer information personal identification items0 issued by
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// State or province in which the customer’s driver’s license was issued. Use the State, Province, and Territory Codes for the United States and Canada.
	//
	// **Important**:
	// Contact your TeleCheck representative to learn whether this field is required or optional.
	//
	// Example: CA
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 buyer information personal identification items0 issued by
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 buyer information personal identification items0 issued by based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card payment instruments for instrument identifier embedded payment instruments items0 card
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card struct {

	// Two-digit month in which the credit card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. For more information about relaxed requirements, see the TMS REST API Developer Guide.
	//
	// Important:
	// It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Example: 12
	// Max Length: 2
	// Min Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	// Format: `YYYY`.
	// Possible values: `1900` through `2099`.
	//
	// **FDC Nashville Global and FDMS South**
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.
	//
	// This field is optional if your CyberSource account is configured for relaxed requirements for address data and expiration date. For details, see [Relaxed Requirements for Address Data and Expiration Date.](https://www.cybersource.com/developers/integration_methods/relax_avs/).
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.'
	//
	// Example: 2022
	// Max Length: 4
	// Min Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder.
	// Example: 01
	// Max Length: 2
	// Min Length: 1
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period.
	//
	// Format: `MM`.
	// Possible values: `01` through `12`.
	//
	// Example: 12
	// Max Length: 2
	// Min Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period.
	//
	// Format: `YYYY`.
	// Possible values: `1900` through `2099`.
	//
	// Example: 2022
	// Max Length: 4
	// Min Length: 4
	StartYear string `json:"startYear,omitempty"`

	// Type of credit card. Possible values:
	//   * **visa** -- Visa (001)
	//   * **mastercard** -- Mastercard (002) - Eurocard—European regional brand of Mastercard
	//   * **american express** -- American Express (003)
	//   * **discover** -- Discover (004)
	//   * **diners club** -- Diners Club (005)
	//   * **carte blanche** -- Carte Blanche (006)
	//   * **jcb** -- JCB (007)
	//   * **optima** -- Optima (008)
	//   * **twinpay credit** -- Twinpay Credit (011)
	//   * **twinpay debit** -- Twinpay Debit (012)
	//   * **walmart** -- Walmart (013)
	//   * **enroute** -- EnRoute (014)
	//   * **lowes consumer** -- Lowes consumer (015)
	//   * **home depot consumer** -- Home Depot consumer (016)
	//   * **mbna** -- MBNA (017)
	//   * **dicks sportswear** -- Dicks Sportswear (018)
	//   * **casual corner** -- Casual Corner (019)
	//   * **sears** -- Sears (020)
	//   * **jal** -- JAL (021)
	//   * **disney** -- Disney (023)
	//   * **maestro uk domestic** -- Maestro (024) - UK Domestic
	//   * **sams club consumer** -- Sams Club consumer (025)
	//   * **sams club business** -- Sams Club business (026)
	//   * **bill me later** -- Bill me later (028)
	//   * **bebe** -- Bebe (029)
	//   * **restoration hardware** -- Restoration Hardware (030)
	//   * **delta online** -- Delta (031) — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * **solo** -- Solo (032)
	//   * **visa electron** -- Visa Electron (033)
	//   * **dankort** -- Dankort (034)
	//   * **laser** -- Laser (035)
	//   * **carte bleue** -- Carte Bleue (036) — formerly Cartes Bancaires
	//   * **carta si** -- Carta Si (037)
	//   * **pinless debit** -- pinless debit (038)
	//   * **encoded account** -- encoded account (039)
	//   * **uatp** -- UATP (040)
	//   * **household** -- Household (041)
	//   * **maestro international** -- Maestro (042) - International
	//   * **ge money uk** -- GE Money UK (043)
	//   * **korean cards** -- Korean cards (044)
	//   * **style** -- Style (045)
	//   * **jcrew** -- JCrew (046)
	//   * **payease china processing ewallet** -- PayEase China processing eWallet (047)
	//   * **payease china processing bank transfer** -- PayEase China processing bank transfer (048)
	//   * **meijer private label** -- Meijer Private Label (049)
	//   * **hipercard** -- Hipercard (050) — supported only by the Comercio Latino processor.
	//   * **aura** -- Aura (051) — supported only by the Comercio Latino processor.
	//   * **redecard** -- Redecard (052)
	//   * **elo** -- Elo (054) — supported only by the Comercio Latino processor.
	//   * **capital one private label** -- Capital One Private Label (055)
	//   * **synchrony private label** -- Synchrony Private Label (056)
	//   * **costco private label** -- Costco Private Label (057)
	//   * **mada** -- mada (060)
	//   * **china union pay** -- China Union Pay (062)
	//   * **falabella private label** -- Falabella private label (063)
	//
	// Required: true
	Type *string `json:"type"`

	// Card Use As Field. Supported value of `pinless debit` only. Only for use with Pinless Debit tokens.
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 card
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"expirationMonth", "body", m.ExpirationMonth, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"expirationMonth", "body", m.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"expirationYear", "body", m.ExpirationYear, 4); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"expirationYear", "body", m.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.IssueNumber) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"issueNumber", "body", m.IssueNumber, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"issueNumber", "body", m.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(m.StartMonth) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"startMonth", "body", m.StartMonth, 2); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"startMonth", "body", m.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(m.StartYear) { // not required
		return nil
	}

	if err := validate.MinLength("card"+"."+"startYear", "body", m.StartYear, 4); err != nil {
		return err
	}

	if err := validate.MaxLength("card"+"."+"startYear", "body", m.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) validateType(formats strfmt.Registry) error {

	if err := validate.Required("card"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 card based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Card
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier payment instruments for instrument identifier embedded payment instruments items0 instrument identifier
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier struct {

	// links
	Links *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// card
	Card *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard `json:"card,omitempty"`

	// The ID of the existing instrument identifier to be linked to the newly created payment instrument.
	// Example: 1234567890123456789
	// Max Length: 32
	// Min Length: 16
	ID string `json:"id,omitempty"`

	// metadata
	Metadata *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// 'Describes type of token.'
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// 'Current state of the token.'
	//
	// Valid values:
	// - ACTIVE
	// - CLOSED
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.BankAccount) { // not required
		return nil
	}

	if m.BankAccount != nil {
		if err := m.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(m.Card) { // not required
		return nil
	}

	if m.Card != nil {
		if err := m.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"id", "body", m.ID, 16); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"id", "body", m.ID, 32); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(m.ProcessingInformation) { // not required
		return nil
	}

	if m.ProcessingInformation != nil {
		if err := m.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {

		if swag.IsZero(m.Links) { // not required
			return nil
		}

		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.BankAccount != nil {

		if swag.IsZero(m.BankAccount) { // not required
			return nil
		}

		if err := m.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if m.Card != nil {

		if swag.IsZero(m.Card) { // not required
			return nil
		}

		if err := m.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {

		if swag.IsZero(m.Metadata) { // not required
			return nil
		}

		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instrumentIdentifier"+"."+"object", "body", string(m.Object)); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if m.ProcessingInformation != nil {

		if swag.IsZero(m.ProcessingInformation) { // not required
			return nil
		}

		if err := m.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "instrumentIdentifier"+"."+"state", "body", string(m.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount payment instruments for instrument identifier embedded payment instruments items0 instrument identifier bank account
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount struct {

	// Checking account number.
	// Example: 1234567890123456800
	// Max Length: 19
	// Min Length: 1
	Number string `json:"number,omitempty"`

	// Routing number.
	// Example: 123456789
	// Max Length: 9
	// Min Length: 1
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier bank account
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", m.Number, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", m.Number, 19); err != nil {
		return err
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount) validateRoutingNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.RoutingNumber) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"bankAccount"+"."+"routingNumber", "body", m.RoutingNumber, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"bankAccount"+"."+"routingNumber", "body", m.RoutingNumber, 9); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier bank account based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard payment instruments for instrument identifier embedded payment instruments items0 instrument identifier card
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard struct {

	// Customer’s credit card number.
	// Example: 1234567890987654
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier card
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"card"+"."+"number", "body", m.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"card"+"."+"number", "body", m.Number, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier card based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks struct {

	// ancestor
	Ancestor *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor `json:"ancestor,omitempty"`

	// self
	Self *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf `json:"self,omitempty"`

	// successor
	Successor *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor `json:"successor,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAncestor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuccessor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) validateAncestor(formats strfmt.Registry) error {
	if swag.IsZero(m.Ancestor) { // not required
		return nil
	}

	if m.Ancestor != nil {
		if err := m.Ancestor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) validateSuccessor(formats strfmt.Registry) error {
	if swag.IsZero(m.Successor) { // not required
		return nil
	}

	if m.Successor != nil {
		if err := m.Successor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAncestor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuccessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) contextValidateAncestor(ctx context.Context, formats strfmt.Registry) error {

	if m.Ancestor != nil {

		if swag.IsZero(m.Ancestor) { // not required
			return nil
		}

		if err := m.Ancestor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {

		if swag.IsZero(m.Self) { // not required
			return nil
		}

		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) contextValidateSuccessor(ctx context.Context, formats strfmt.Registry) error {

	if m.Successor != nil {

		if swag.IsZero(m.Successor) { // not required
			return nil
		}

		if err := m.Successor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links ancestor
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links ancestor
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links ancestor based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksAncestor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links self
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links self
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links self based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links successor
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links successor
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier links successor based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierLinksSuccessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata payment instruments for instrument identifier embedded payment instruments items0 instrument identifier metadata
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata struct {

	// The creator of the token.
	// Example: merchantName
	Creator string `json:"creator,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier metadata
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier metadata based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizationOptions) { // not required
		return nil
	}

	if m.AuthorizationOptions != nil {
		if err := m.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthorizationOptions != nil {

		if swag.IsZero(m.AuthorizationOptions) { // not required
			return nil
		}

		if err := m.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(m.Initiator) { // not required
		return nil
	}

	if m.Initiator != nil {
		if err := m.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if m.Initiator != nil {

		if swag.IsZero(m.Initiator) { // not required
			return nil
		}

		if err := m.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options initiator
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options initiator
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if m.MerchantInitiatedTransaction != nil {
		if err := m.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options initiator based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantInitiatedTransaction != nil {

		if swag.IsZero(m.MerchantInitiatedTransaction) { // not required
			return nil
		}

		if err := m.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options initiator merchant initiated transaction
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Previous Consumer Initiated Transaction Id.
	// Example: 123456789012345
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options initiator merchant initiated transaction
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(m.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", m.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0InstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links payment instruments for instrument identifier embedded payment instruments items0 links
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links struct {

	// ancestor
	Ancestor *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor `json:"ancestor,omitempty"`

	// self
	Self *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf `json:"self,omitempty"`

	// successor
	Successor *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor `json:"successor,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 links
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAncestor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuccessor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) validateAncestor(formats strfmt.Registry) error {
	if swag.IsZero(m.Ancestor) { // not required
		return nil
	}

	if m.Ancestor != nil {
		if err := m.Ancestor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) validateSuccessor(formats strfmt.Registry) error {
	if swag.IsZero(m.Successor) { // not required
		return nil
	}

	if m.Successor != nil {
		if err := m.Successor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 links based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAncestor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuccessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) contextValidateAncestor(ctx context.Context, formats strfmt.Registry) error {

	if m.Ancestor != nil {

		if swag.IsZero(m.Ancestor) { // not required
			return nil
		}

		if err := m.Ancestor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "ancestor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "ancestor")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {

		if swag.IsZero(m.Self) { // not required
			return nil
		}

		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) contextValidateSuccessor(ctx context.Context, formats strfmt.Registry) error {

	if m.Successor != nil {

		if swag.IsZero(m.Successor) { // not required
			return nil
		}

		if err := m.Successor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "successor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "successor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor payment instruments for instrument identifier embedded payment instruments items0 links ancestor
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 links ancestor
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 links ancestor based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksAncestor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf payment instruments for instrument identifier embedded payment instruments items0 links self
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 links self
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 links self based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor payment instruments for instrument identifier embedded payment instruments items0 links successor
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/1234567890123456789
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 links successor
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 links successor based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0LinksSuccessor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation payment instruments for instrument identifier embedded payment instruments items0 merchant information
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 merchant information
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(m.MerchantDescriptor) { // not required
		return nil
	}

	if m.MerchantDescriptor != nil {
		if err := m.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 merchant information based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if m.MerchantDescriptor != nil {

		if swag.IsZero(m.MerchantDescriptor) { // not required
			return nil
		}

		if err := m.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor payment instruments for instrument identifier embedded payment instruments items0 merchant information merchant descriptor
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor struct {

	// Alternate information for your business. This API field overrides the company entry description value in your CyberSource account.
	// Example: Branch Name
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 merchant information merchant descriptor
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 merchant information merchant descriptor based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData payment instruments for instrument identifier embedded payment instruments items0 meta data
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData struct {

	// The creator of the token.
	// Example: merchantName
	Creator string `json:"creator,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 meta data
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 meta data based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0MetaData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation payment instruments for instrument identifier embedded payment instruments items0 processing information
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Indicates that the payments for this customer profile are for the Bill Payment program. Possible values:
	//   * false: Not a Visa Bill Payment.
	//   * true: Visa Bill Payment.
	//
	// Example: true
	BillPaymentProgramEnabled *bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 processing information
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.BankTransferOptions) { // not required
		return nil
	}

	if m.BankTransferOptions != nil {
		if err := m.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier embedded payment instruments items0 processing information based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.BankTransferOptions != nil {

		if swag.IsZero(m.BankTransferOptions) { // not required
			return nil
		}

		if err := m.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions payment instruments for instrument identifier embedded payment instruments items0 processing information bank transfer options
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions
type PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions struct {

	// **Important** This field is required if your processor is TeleCheck.
	//
	// Code that specifies the authorization method for the transaction. Possible values:
	//
	// - **CCD**: corporate cash disbursement. Charge or credit against a business checking account. You can use one-time or recurring CCD transactions to transfer funds to or from a corporate entity. A standing authorization is required for recurring transactions.
	// - **PPD**: prearranged payment and deposit entry. Charge or credit against a personal checking or savings account. You can originate a PPD entry only when the payment and deposit terms between you and the customer are prearranged. A written authorization from the customer is required for one-time transactions and a written standing authorization is required for recurring transactions.
	// - **TEL**: telephone-initiated entry. One-time charge against a personal checking or savings account. You can originate a TEL entry only when there is a business relationship between you and the customer or when the customer initiates a telephone call to you. For a TEL entry, you must obtain a payment authorization from the customer over the telephone. There is no recurring billing option for TEL.
	// - **WEB**: internet-initiated entry—charge against a personal checking or savings account. You can originate a one-time or recurring WEB entry when the customer initiates the transaction over the Internet. For a WEB entry, you must obtain payment authorization from the customer over the Internet.
	//
	// Example: WEB
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this payment instruments for instrument identifier embedded payment instruments items0 processing information bank transfer options
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier embedded payment instruments items0 processing information bank transfer options based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierLinks payment instruments for instrument identifier links
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierLinks
type PaymentInstrumentsForInstrumentIdentifierLinks struct {

	// first
	First *PaymentInstrumentsForInstrumentIdentifierLinksFirst `json:"first,omitempty"`

	// last
	Last *PaymentInstrumentsForInstrumentIdentifierLinksLast `json:"last,omitempty"`

	// next
	Next *PaymentInstrumentsForInstrumentIdentifierLinksNext `json:"next,omitempty"`

	// prev
	Prev *PaymentInstrumentsForInstrumentIdentifierLinksPrev `json:"prev,omitempty"`

	// self
	Self *PaymentInstrumentsForInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this payment instruments for instrument identifier links
func (m *PaymentInstrumentsForInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrev(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) validateFirst(formats strfmt.Registry) error {
	if swag.IsZero(m.First) { // not required
		return nil
	}

	if m.First != nil {
		if err := m.First.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "first")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "first")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) validateLast(formats strfmt.Registry) error {
	if swag.IsZero(m.Last) { // not required
		return nil
	}

	if m.Last != nil {
		if err := m.Last.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "last")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "last")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) validateNext(formats strfmt.Registry) error {
	if swag.IsZero(m.Next) { // not required
		return nil
	}

	if m.Next != nil {
		if err := m.Next.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "next")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) validatePrev(formats strfmt.Registry) error {
	if swag.IsZero(m.Prev) { // not required
		return nil
	}

	if m.Prev != nil {
		if err := m.Prev.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "prev")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "prev")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(m.Self) { // not required
		return nil
	}

	if m.Self != nil {
		if err := m.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payment instruments for instrument identifier links based on the context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFirst(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLast(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrev(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) contextValidateFirst(ctx context.Context, formats strfmt.Registry) error {

	if m.First != nil {

		if swag.IsZero(m.First) { // not required
			return nil
		}

		if err := m.First.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "first")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "first")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) contextValidateLast(ctx context.Context, formats strfmt.Registry) error {

	if m.Last != nil {

		if swag.IsZero(m.Last) { // not required
			return nil
		}

		if err := m.Last.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "last")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "last")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) contextValidateNext(ctx context.Context, formats strfmt.Registry) error {

	if m.Next != nil {

		if swag.IsZero(m.Next) { // not required
			return nil
		}

		if err := m.Next.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "next")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) contextValidatePrev(ctx context.Context, formats strfmt.Registry) error {

	if m.Prev != nil {

		if swag.IsZero(m.Prev) { // not required
			return nil
		}

		if err := m.Prev.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "prev")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "prev")
			}
			return err
		}
	}

	return nil
}

func (m *PaymentInstrumentsForInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if m.Self != nil {

		if swag.IsZero(m.Self) { // not required
			return nil
		}

		if err := m.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierLinksFirst payment instruments for instrument identifier links first
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierLinksFirst
type PaymentInstrumentsForInstrumentIdentifierLinksFirst struct {

	// A link to the collection starting at offset zero for the supplied limit.
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/5B32CE6167B09343E05333B9D30A53E1/paymentinstruments?offset=0\u0026limit=5
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier links first
func (m *PaymentInstrumentsForInstrumentIdentifierLinksFirst) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier links first based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierLinksFirst) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksFirst) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksFirst) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierLinksFirst
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierLinksLast payment instruments for instrument identifier links last
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierLinksLast
type PaymentInstrumentsForInstrumentIdentifierLinksLast struct {

	// A link to the last collection containing the remaining objects.
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/5B32CE6167B09343E05333B9D30A53E1/paymentinstruments?offset=35\u0026limit=5
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier links last
func (m *PaymentInstrumentsForInstrumentIdentifierLinksLast) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier links last based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierLinksLast) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksLast) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksLast) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierLinksLast
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierLinksNext payment instruments for instrument identifier links next
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierLinksNext
type PaymentInstrumentsForInstrumentIdentifierLinksNext struct {

	// A link to the next collection starting at the supplied offset plus the supplied limit.
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/5B32CE6167B09343E05333B9D30A53E1/paymentinstruments?offset=25\u0026limit=5
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier links next
func (m *PaymentInstrumentsForInstrumentIdentifierLinksNext) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier links next based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierLinksNext) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksNext) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksNext) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierLinksNext
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierLinksPrev A link to the previous collection starting at the supplied offset minus the supplied limit.
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierLinksPrev
type PaymentInstrumentsForInstrumentIdentifierLinksPrev struct {

	// href
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/5B32CE6167B09343E05333B9D30A53E1/paymentinstruments?offset=15\u0026limit=5
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier links prev
func (m *PaymentInstrumentsForInstrumentIdentifierLinksPrev) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier links prev based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierLinksPrev) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksPrev) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksPrev) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierLinksPrev
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PaymentInstrumentsForInstrumentIdentifierLinksSelf payment instruments for instrument identifier links self
//
// swagger:model PaymentInstrumentsForInstrumentIdentifierLinksSelf
type PaymentInstrumentsForInstrumentIdentifierLinksSelf struct {

	// A link to the current requested collection.
	// Example: https://api.cybersource.com/tms/v1/instrumentidentifiers/5B32CE6167B09343E05333B9D30A53E1/paymentinstruments?offset=20\u0026limit=5\
	Href string `json:"href,omitempty"`
}

// Validate validates this payment instruments for instrument identifier links self
func (m *PaymentInstrumentsForInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payment instruments for instrument identifier links self based on context it is used
func (m *PaymentInstrumentsForInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentInstrumentsForInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PaymentInstrumentsForInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
